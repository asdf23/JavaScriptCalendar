<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<link rel="icon" type="image/svg+xml" href="/calendar.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Calendar</title>
		<script src="DBUtils.js"></script>
	</head>
	<body>
		<script type="module" src="/main.js"></script>
	</body>
	<script>
		function objectHasAllProperties(object, properties) {
			return properties.every(prop => object.hasOwnProperty(prop));
		}
		function adjustExistingScale(originalString, bumpScale) {
			let regex = /scale\(([+-]?\d+(\.\d+)?)\)/g;
			return originalString.replace(regex, (match, number) => {
				let oldValue = parseFloat(number);
				let newValue = oldValue + (oldValue * bumpScale);
				newValue = newValue.toFixed(2);
				return `scale(${newValue})`;
			});
		}
		function adjustExistingY(originalString, bumpY, height) {
			let regex = /translate\(\s*([+-]?\d+(\.\d+)?),\s*([+-]?\d+(\.\d+)?)\s*\)/g;
			return originalString.replace(regex, (match, x, _, y) => {
				let oldValueY = parseFloat(y);
				let increment = height * bumpY;
				let newValueY = oldValueY + increment;
				newValueY = newValueY.toFixed(2);
				return `translate(${x}, ${newValueY})`;
			});
		}
		function applyAttribtesToSVGDom(d, attrs) {
			var textAttributesSpecialCase = ["x", "y", "width", "height", "text"];
			var textExcludeAdditionalSpecialCaseAttributes = ["bumpScale", "bumpY", "overrideCenterPosition"];
			if( d.tagName == "text" && objectHasAllProperties(attrs, textAttributesSpecialCase) ) {
				//console.log("in text");
				Object.keys(attrs)
					.filter(f=> !textAttributesSpecialCase.includes(f))
					.filter(f=> !textExcludeAdditionalSpecialCaseAttributes.includes(f))
					.forEach(f=> {
						d.setAttribute(f, attrs[f]);
				});
				if(! ("overrideCenterPosition" in attrs)) {
					d.setAttribute("text-anchor", "middle");
				}
				d.setAttribute("dominant-baseline", "middle");
				d.textContent = attrs.text;
				var textSize = d.getBoundingClientRect();
				var textScale = calculateScale(attrs, textSize);
				if("bumpScale" in attrs) {
					textScale += textScale * attrs.bumpScale;
				}
				if("bumpY" in attrs) {
					attrs.y += attrs.height * attrs.bumpY;
				}
				d.setAttribute("transform", `translate(${attrs.x}, ${attrs.y}) scale(${textScale})`);
			} else {
				if(d.tagName == "text") {
					Object.keys(attrs)
						.filter(f=> !textExcludeAdditionalSpecialCaseAttributes.includes(f))
						.forEach(f=> {
							d.setAttribute(f, attrs[f]);
						});
					if("bumpScale" in attrs) {
						//console.log("was", d.getAttribute("transform"));
						//console.log("new", adjustExistingScale(d.getAttribute("transform"), attrs.bumpScale))
						d.setAttribute("transform", adjustExistingScale(d.getAttribute("transform"), attrs.bumpScale));
					}
					if("bumpY" in attrs) {
						let height = d.getBoundingClientRect().height;
						d.setAttribute("transform", adjustExistingY(d.getAttribute("transform"), attrs.bumpY, height));
					}
				}
				for(var i in attrs) {
					if(d.tagName == "use" && i == "xlink:href") {
						d.setAttributeNS("http://www.w3.org/1999/xlink", 'xlink:href', attrs[i]);
					} else {
						d.setAttribute(i, attrs[i]);
					}
				}
			}
		}
		function createSVGDom(tag,attrs,appendTo) {
			var d = document.createElementNS("http://www.w3.org/2000/svg", tag);
			if(appendTo!=null) {
				appendTo.appendChild(d);
			}
			if(attrs != null) {
				if("length" in attrs) {
					let attr = Object.assign.apply(null, [{}].concat(attrs));
					applyAttribtesToSVGDom(d, attr);
				} else {
					applyAttribtesToSVGDom(d, attrs);
				}
				// if("length" in attrs) {
				// 	attrs.forEach(attr=> {
				// 		applyAttribtesToSVGDom(d, attr);
				// 	});
				// } else {
				// 	applyAttribtesToSVGDom(d, attrs);
				// }
			}
			return d;
		}
		function createCalendar(width, height, x, y, date, options ={}, appendToChild) {
			/*
				0 Sun
				1 Mon
				2 Tues
				3 Wed
				4 Thu
				5 Fri
				6 Sat
			*/
			const { 
				 weekStart = 0
				,highLightWeekend = true
				,highlightWrongMonths = true 
				,useShortYear = false
				,useShortMonthName = true
				,useShortWeekName = true
				,showMonthNavigation = false
				,displayEvents = false
				,styleCalendar = {
								 stroke: "black"
								,fill:"lightgray"
							}
				,styleYearMonthDivider = {
								 stroke:"black"
								,"stroke-width": 2
							}
				,styleMonthDatesDivider = {
								stroke:"black"
							}
				,styleDatesVerticleDivider = {
								stroke:"black"
							}
				,styleDatesHorizontalDivider = {
								stroke:"black"
							}
				,styleOffMonthHighlight = {
								 fill: "black"
								,opacity: 0.2
							}
				,styleDateNumberBackground = {
								 opacity: 0.5
								,fill:"lightblue"
								,stroke: "black"
							}
				,styleWeekend = {
								 opacity: 0.2
								,fill: "yellow"
							}
				,styleYearMonthText = {
								"font-family": "sans-serif"
								,bumpScale: 0.3
								,bumpY: 0.08
							}
				,styleWeekDayText = {
								"font-family": "sans-serif"
								,bumpScale: useShortWeekName ? 0.3 : 0
								,bumpY: 0.08
							}
				,styleDateText = {
								"font-family": "sans-serif"
								,bumpScale: 0.3
								,bumpY: 0.08
							}
				,styleMonthChangeControl = {
								"font-family": "sans-serif"
								,bumpScale: 0.3
								,bumpY: 0.08
								,cursor: "pointer"
							}
				,styleEventSlotBackground = {
								 fill: "lightgreen"
								,stroke: "black"
								,"stroke-width": 0.5
								,cursor: "pointer"
							}
				,styleEventSlotText = {
								 fill: "red"
								,bumpScale: -0.09
								,"font-family": "sans-serif"
							}
				,styleEventIconText = {
								 bumpScale: -0.15
							}
			} = options;

			if(date == null) {
				date = new Date();
			}
			date = new Date(date.getFullYear(), date.getMonth(), 1);
			var displayedDate = new Date(date.getTime());
			
			//var dynamicDiv = document.getElementById('dynamicDiv');
			var dynamicDiv =  document.createElement("div");
			//dynamicDiv.style.position = "absolute";
			dynamicDiv.style.backgroundColor = "#f0f0f0";
			dynamicDiv.style.border = "1px solid #ccc";
			appendToChild.appendChild(dynamicDiv);
			var calendarID = 'calendar' + findExistingCalendars(appendToChild);
		
			// Constants for offsets
			var offsetLeft = 0;
			var offsetRight = 0;
			var offsetTop = 20;
			var offsetBottom = 0;

			const monthNames = Array.from({ length: 12 }, (_, index) => {
				const tempDate = new Date(date.getFullYear(), index, 1);
				return {
					longName: tempDate.toLocaleString('default', { month: 'long' }),
					shortName: tempDate.toLocaleString('default', { month: 'short' })
				};
			});

			const weekNames = Array.from({ length: 7 }, (_, index) => {
				const tempDate = new Date(date.getFullYear(), 0, index);
					return {
						longName: tempDate.toLocaleString('default', { weekday: 'long' }),
						shortName: tempDate.toLocaleString('default', { weekday: 'short' })
					};
			});

			
			// Calculate the width and height of rectDay & rectDate
			var rectDayWidthPercentage = (100 - (offsetLeft + offsetRight)) / 7;
			var rectDayHeightPercentage = (100 - (offsetTop + offsetBottom)) / 6;
			var rectDateWidthPercentage = rectDayWidthPercentage * 0.25;
			var rectDateHeightPercentage = rectDayHeightPercentage * 0.25;
			var textX = parseFloat(0) + parseFloat(rectDayWidthPercentage) / 2;
			var textY = parseFloat(0) + parseFloat(rectDayHeightPercentage) / 2;
		
			// Create the calendar div
			var calendarDiv = document.createElement('div');
			calendarDiv.setAttribute('id', calendarID);
			calendarDiv.style.width = width + 'px';
			calendarDiv.style.height = height + 'px';
			calendarDiv.style.left = x + 'px';
			calendarDiv.style.top = y + 'px';
			calendarDiv.style.position = "absolute";
			//calendarDiv.style.border = '1px solid black'; // Adding border
			
			var xMonthLine = (height / 8) * 1.5;								//Horizontal line below month
			var xWeekLine = xMonthLine + ((height / 8) * 0.5);					//Horizontal line below week
			var yWeekLine1 = width / 7;											//Width of dates
			var xWeekLine1 = (height / 8);										//Height of dates
			var xDateLine1 = xWeekLine1 / 4;									//Height of #
			var yDateLine1 = yWeekLine1 / 4;									//Width of #
			var svgElement = createSVGDom("svg", {width:width, height:height, "xmlns":"http://www.w3.org/2000/svg"});
			var centerX = width / 2;

			calendarDiv.appendChild(svgElement);
			dynamicDiv.appendChild(calendarDiv);

			createSVGDom("rect", [{
								 width: width
								,height: height
								,rx: (width*2)/100
								,ry: (height*2)/100
							}, styleCalendar],svgElement);
			var gDayHighlights = createSVGDom("g", {
					class: "dayHighlightArea"
				}, svgElement);
			createSVGDom("path", [{
								 d:`M 0,${xMonthLine} L ${width},${xMonthLine}`
							}, styleYearMonthDivider], svgElement);
			createSVGDom("path", [{
								 d:`M 0,${xWeekLine} L ${width},${xWeekLine}`
							}, styleMonthDatesDivider], svgElement);
			for(var wl=1; wl<=6; wl++) {
				// createSVGDom("path", {
				// 		stroke:"red"
				// 		,"stroke-width": 2
				// 		,d:`M ${yWeekLine1*wl},${xMonthLine} L ${yWeekLine1*wl},${height}`}
				// 	, svgElement);
				createSVGDom("path", [{
									 d:`M ${yWeekLine1*wl},${xMonthLine} L ${yWeekLine1*wl},${height}`
								}, styleDatesVerticleDivider], svgElement);
				if(wl < 6) {
					createSVGDom("path", [{
								 d:`M 0,${xWeekLine+xWeekLine1*wl} L ${width},${xWeekLine+xWeekLine1*wl}`
								}, styleDatesHorizontalDivider], svgElement);
				}
			}

			var dateMonth = new Date(date.getTime());
			//console.log("Month", dateMonth);
			while(date.getDay() != weekStart) {
				date.setDate(date.getDate() - 1);
			}
			var firstDisplayDate = new Date(date.getTime());
			var startDate = new Date(firstDisplayDate.getTime());
			console.log("First display date", firstDisplayDate.toLocaleString(), firstDisplayDate.getDay());
			if(highlightWrongMonths) {
				if(firstDisplayDate.getMonth() == dateMonth.getMonth()) {
					//No need to highlight wrong month days
				} else {
					var differenceInMilliseconds = Math.abs(dateMonth.getTime() - firstDisplayDate.getTime());
					var differenceInDays = Math.ceil(differenceInMilliseconds / (1000 * 60 * 60 * 24));
					createSVGDom("rect", [{
												 x:0
												,y: xWeekLine
												,width: yWeekLine1 * differenceInDays
												,height: xWeekLine1
											}, styleOffMonthHighlight ], gDayHighlights);
				}
			}


			var yearText = dateMonth.getFullYear().toString().split("");
			if(useShortYear) {
				yearText.shift();
				yearText.shift();
			}
			yearText = yearText.join("");
			if(useShortMonthName) {
				yearText = `${monthNames[dateMonth.getMonth()].shortName} ${yearText}`;
			} else {
				yearText = `${monthNames[dateMonth.getMonth()].longName} ${yearText}`;
			}

			var gYear = createSVGDom("g", null, svgElement);
			createSVGDom("text", [{
								 x: width / 2
								,y: xMonthLine / 2
								,width: width
								,height: xMonthLine
								,text: yearText
							}, styleYearMonthText], gYear);

			var dateWeek = new Date(date.getTime());
			var gWeek = createSVGDom("g", null, svgElement);
			for(var i=0; i<7; i++) {
				var weekID = dateWeek.getDay();
				createSVGDom("text", [{
									 x: yWeekLine1*i + (yWeekLine1/2)
									,y: xMonthLine + ((xWeekLine - xMonthLine)/2)
									,width: yWeekLine1
									,height: xWeekLine - xMonthLine
									,text: weekNames[weekID][useShortWeekName ? "shortName" : "longName"]
								}, styleWeekDayText], gWeek);
				dateWeek.setDate(dateWeek.getDate()+1);
			}
			var gDates = createSVGDom("g", null,  svgElement);
			var didHighLightForX = [];
			for(var yDate=0; yDate<6; yDate++) {
				for(var xDate=0; xDate<7; xDate++) {
					//Date #
					var dateRect = createSVGDom("rect", [{
													 x: xDate*yWeekLine1
													,y: yDate*xWeekLine1 + xWeekLine 
													,width: yDateLine1
													,height: xDateLine1
												}, styleDateNumberBackground], gDates);
					createSVGDom("title", {},  dateRect).textContent = date.toLocaleString();
					var dateScale = Math.min(xDateLine1/100, (yDateLine1*2)/100);
					var dateString = date.getDate().toString();
					createSVGDom("text", [{
										 x: xDate*yWeekLine1 + yDateLine1/2
										,y: yDate*xWeekLine1 + xWeekLine  + xDateLine1/2
										,width: yDateLine1
										,height: xDateLine1
										,text: dateString
									}, styleDateText], gDates);

					if(highLightWeekend) {
						if(yDate==0) {
							if(date.getDay() == 0 || date.getDay() == 6) {
								//console.log("date.getDay():", date.getDay(), "x:", x);
								//highligh verticle strip
								if(xDate==0) {
									//console.log("drawing vert highlight for ", x, date.getDay());
									createSVGDom("rect", [{
															 x: yWeekLine1*xDate
															,y: xWeekLine
															,width: yWeekLine1
															,height: height - xWeekLine
															,style: `clip-path: inset(0px 0px 0px 0px round 0px 0px 0px 10px);`
														}, styleWeekend], gDayHighlights);
								} else if(xDate==6) {
									//console.log("drawing vert highlight for ", y, date.getDay());
									createSVGDom("rect", [{
															 x: yWeekLine1*xDate
															,y: xWeekLine
															,width: yWeekLine1
															,height: height - xWeekLine
															,style: `clip-path: inset(0px 0px 0px 0px round 0px 0px 10px 0px);`
														}, styleWeekend], gDayHighlights);
								} else {
									//console.log("drawing vert highlight for ", y, date.getDay());
									createSVGDom("rect", [{
															 x: yWeekLine1*xDate
															,y: xWeekLine
															,width: yWeekLine1
															,height: height - xWeekLine
														}, styleWeekend], gDayHighlights);
							  	}
							}
						}
						if(highlightWrongMonths && (date.getMonth() > dateMonth.getMonth() || date.getFullYear() > dateMonth.getFullYear()) && yDate > 0) {
							if(! didHighLightForX.includes(yDate)) {
								//console.log("Consdier off month highlight", date.getMonth(),">",dateMonth.getMonth(), "width:", 7-xDate, "x(row)", yDate);
								didHighLightForX.push(yDate);
								if(yDate != 5) {
									createSVGDom("rect", [{
															 x: yWeekLine1*(xDate)
															,y: xWeekLine + xWeekLine1*yDate
															,width: yWeekLine1* (7-xDate)
															,height: xWeekLine1
														}, styleOffMonthHighlight], gDayHighlights);
								} else {
									var l = "0";
									var r = 10;
									if(xDate == 0) {
										l = "10";
									}
									createSVGDom("rect", [{
															 x: yWeekLine1*(xDate)
															,y: xWeekLine + xWeekLine1*yDate
															,width: yWeekLine1* (7-xDate)
															,height: xWeekLine1
															,style: `clip-path: inset(0px 0px 0px 0px round 0px 0px ${r}px ${l}px);`
														}, styleOffMonthHighlight], gDayHighlights);
								}
							}
						}
					}
					date.setDate(date.getDate()+1);
				}
			}
			var endedDate = new Date(date.getTime());
			//console.log("startDate",startDate);
			//console.log("endedDate",endedDate);
			//calendarDiv.appendChild(svgElement);
			//dynamicDiv.appendChild(calendarDiv);
			calendarDiv.showMonthNavigation = showMonthNavigation;
			calendarDiv.displayEvents = displayEvents;
			if(showMonthNavigation) {
				let domPrevMonth = createSVGDom("text", [{
									 x: yWeekLine1 / 4
									,y: xMonthLine / 2
									,width: yWeekLine1 / 2
									,height: xMonthLine
									,text: "‚¨ÖÔ∏è"
								}, styleMonthChangeControl], svgElement);
				let domNextMonth = createSVGDom("text", [{
									 x: width - (yWeekLine1 / 4)
									,y: xMonthLine / 2
									,width: yWeekLine1 / 2
									,height: xMonthLine
									,text: "‚û°Ô∏è"
								}, styleMonthChangeControl], svgElement);
				
				function previousMonthClick() {
					var prevMonth = new Date(dateMonth.getFullYear(), dateMonth.getMonth()-1, dateMonth.getDate());
					appendToChild.removeChild(dynamicDiv);
					console.log(x,y);
					let c  = createCalendar(width, height, x, y, prevMonth, {weekStart ,highLightWeekend ,highlightWrongMonths ,useShortYear ,useShortMonthName ,useShortWeekName ,showMonthNavigation ,styleCalendar ,styleYearMonthDivider ,styleMonthDatesDivider ,styleDatesVerticleDivider ,styleDatesHorizontalDivider ,styleOffMonthHighlight ,styleDateNumberBackground ,styleWeekend ,styleYearMonthText ,styleWeekDayText ,styleDateText, styleMonthChangeControl}, appendToChild);
					console.log('dynamicDiv.querySelector("div").showMonthNavigation', dynamicDiv.querySelector("div").showMonthNavigation);
					if(dynamicDiv.querySelector("div").displayEvents) {
						c.showEvents();
					}
				}
				function nextMonthClick() {
					var nextMonth = new Date(dateMonth.getFullYear(), dateMonth.getMonth()+1, dateMonth.getDate());
					appendToChild.removeChild(dynamicDiv);
					console.log(x,y);
					let c = createCalendar(width, height, x, y, nextMonth, {weekStart ,highLightWeekend ,highlightWrongMonths ,useShortYear ,useShortMonthName ,useShortWeekName ,showMonthNavigation ,styleCalendar ,styleYearMonthDivider ,styleMonthDatesDivider ,styleDatesVerticleDivider ,styleDatesHorizontalDivider ,styleOffMonthHighlight ,styleDateNumberBackground ,styleWeekend ,styleYearMonthText ,styleWeekDayText ,styleDateText, styleMonthChangeControl}, appendToChild);
					if(dynamicDiv.querySelector("div").displayEvents) {
						console.log('dynamicDiv.querySelector("div").showMonthNavigation', dynamicDiv.querySelector("div").showMonthNavigation);
						c.showEvents();
					}
				}
				domPrevMonth.addEventListener("click", previousMonthClick);
				domNextMonth.addEventListener("click", nextMonthClick);
			}
			calendarDiv.startDate = new Date(startDate.getTime());
			calendarDiv.endedDate = new Date(endedDate.getTime());
			calendarDiv.displayedDate = new Date(displayedDate.getTime());
			
			//internal functions
			function getDateRangeOverlap(targetStart, targetEnded, rangeStart, rangeEnded) {
				//console.log(`getDateRangeOverlap(${targetStart}, ${targetEnded}, ${rangeStart}, ${rangeEnded})`);
				var dTargetStart = targetStart.getTime();
				var dRangeStart = rangeStart.getTime();
				var dRangeEnded = rangeEnded.getTime();
				var result = null;
				if(targetEnded == null || ((targetEnded != null) && targetEnded.getTime() == dTargetStart) ) {
					//console.log("single point mode");
					/*
						  * |     |     before
						    |  *  |     between
						    |     | *   after
						    *     |     onStart
						    |     *     onEnd
					*/
					if(dTargetStart == dRangeStart) {
						result = {contained: true, type: "onStart", inRange: {start: new Date(dTargetStart), ended: new Date(dTargetStart)}};
					} else if(dTargetStart < dRangeStart) {
						result = {contained: false, type: "before", inRange: null};
					} else if(dTargetStart > dRangeStart && dTargetStart < dRangeEnded) {
						result = {contained: true, type: "between", inRange: {start:new Date(dTargetStart), ended:new Date(dTargetStart)}};
					} else if(dTargetStart > dRangeEnded) {
						result = {contained: false, type: "after", inRange: null};
					} else if(dTargetStart == dRangeEnded) {
						result = {contained: false, type: "onEnd", inRange: null};
					} else {
						throw "Unaccounted date";
					}
					result["chopped"] = {start:false, ended:false};
					return result;
				} else {
					//console.log("range mode");
					/*
					   =]|     |	 before
						|      | [= after
					  ===]     |	 endsOnStart
						|      [= startsOnEnd
						| [=]  |  contains
						| [====== containsPastEnd 
					  ======]  | containsBeforeStart 
						[===]  | containsOnStart
						| [====] containsOnEnd
						[======] containsExactFit
					 [============] containsPastBothEnds
					     [======== containsOnStartPastEnd
					 ==========] containsOnEndBeforeStart
					     |     |

					     start is chopped:
					     	containsOnEndBeforeStart,containsPastBothEnds,containsBeforeStart,endsOnStart
					     end is chopped:
					     	containsOnStartPastEnd,containsPastBothEnds,containsPastEnd 
					    
					*/
					var dTargetEnded = targetEnded.getTime();
					if(
						dTargetStart < dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded < dRangeStart
						&&
						dTargetEnded < dRangeEnded
					) {
						result = {contained: false, type: "before", inRange: null};
					} else if(
						dTargetStart > dRangeStart
						&&
						dTargetStart > dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded > dRangeEnded
					) {
						result = {contained: false, type: "after", inRange: null};
					} else if(
						dTargetStart < dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded == dRangeStart
						&&
						dTargetEnded < dRangeEnded
					) {
						result = {contained: false, type: "endsOnStart", inRange: {start: new Date(dTargetStart), ended: new Date(dTargetStart)}};
					} else if(
						dTargetStart > dRangeStart
						&&
						dTargetStart == dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded > dRangeEnded
					) {
						result = {contained: false, type: "startsOnEnd", inRange: null};
					} else if(
						dTargetStart > dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded < dRangeEnded
					) {
						result = {contained: true, type: "contains", inRange: {start:new Date(dTargetStart), ended:new Date(dTargetEnded)}};
					} else if(
						dTargetStart > dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded > dRangeEnded
					) {
						result = {contained: true, type: "containsPastEnd", inRange: {start:new Date(dTargetStart), ended:new Date(dRangeEnded)}};
					} else if(
						dTargetStart < dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded < dRangeEnded
					) {
						result = {contained: true, type: "containsBeforeStart", inRange: {start:new Date(dRangeStart), ended:new Date(dTargetEnded)}};
					} else if(
						dTargetStart == dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded < dRangeEnded
					) {
						result = {contained: true, type: "containsOnStart", inRange: {start:new Date(dTargetStart), ended:new Date(dTargetEnded)}};
					} else if(
						dTargetStart > dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded == dRangeEnded
					) {
						result = {contained: true, type: "containsOnEnd", inRange: {start:new Date(dTargetStart), ended:new Date(dTargetEnded)}};
					} else if(
						dTargetStart == dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded == dRangeEnded
					) {
						result = {contained: true, type: "containsExactFit", inRange: {start:new Date(dTargetStart), ended:new Date(dTargetEnded)}};
					} else if(
						dTargetStart < dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded > dRangeEnded
					) {
						result = {contained: true, type: "containsPastBothEnds", inRange: {start:new Date(dRangeStart), ended:new Date(dRangeEnded)}};
					} else if(
						dTargetStart == dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded > dRangeEnded
					) {
						result = {contained: true, type: "containsOnStartPastEnd", inRange: {start:new Date(dTargetStart), ended:new Date(dRangeEnded)}};
					} else if(
						dTargetStart < dRangeStart
						&&
						dTargetStart < dRangeEnded
						&&
						dTargetEnded > dRangeStart
						&&
						dTargetEnded == dRangeEnded
					) {
						result = {contained: true, type: "containsOnEndBeforeStart", inRange: {start:new Date(dRangeStart), ended:new Date(dRangeEnded)}};
			// 		} else if(
			// 			dTargetStart < dRangeStart
			// 			&&
			// 			dTargetStart < dRangeEnded
			// 			&&
			// 			dTargetEnded < dRangeStart
			// 			&&
			// 			dTargetEnded < dRangeEnded
			// 		) {
			// 			result = {contained: , type: "", inRange: {start:new Date(xxx), ended:new Date(xxxx}};
					} else {
						function getComparasonOperator(n1,n2) {
							if(n1<n2) { return "<" }
							else if(n1>n2) { return ">" }
							else if(n1==n2) { return "==" }
							else {
								console.error("getComparasonOperator() failed");
								console.error("n1", typeof(n1), n1);
								console.error("n2", typeof(n2), n2);
								throw "??";
							}
						}
						console.log(`dTargetStart ${getComparasonOperator(dTargetStart,dRangeStart)} dRangeStart`);
						console.log(`dTargetStart ${getComparasonOperator(dTargetStart,dRangeEnded)} dRangeEnded`);
						console.log(`dTargetEnded ${getComparasonOperator(dTargetEnded,dRangeStart)} dRangeStart`);
						console.log(`dTargetEnded ${getComparasonOperator(dTargetEnded,dRangeEnded)} dRangeEnded`);
						throw "Unaccounted range"	
					}
					var startIsChopped = ["containsOnEndBeforeStart","containsPastBothEnds","containsBeforeStart","endsOnStart"];
					var endedIsChopped = ["containsOnStartPastEnd","containsPastBothEnds","containsPastEnd"];
					result["chopped"] = {start: startIsChopped.includes(result.type), ended: endedIsChopped.includes(result.type)};
					//console.log(`result.chopped: `, result.chopped);
					return result;
				}
			}
			function getOtherCoordsFromCoordAndWidth(coord, width) {
				var result = [];
				for(var i=1; i<=width; i++) {
					result.push({x: coord.x + i, y: coord.y});
				}
				return result;
			}
			function getAllCoordinatesOfADateRange(aDate, duration) {
				var rows = [];
				for(var i=0; i<6; i++) {
					var ws = new Date(calendarDiv.startDate.getTime());
					ws.setDate(calendarDiv.startDate.getDate() + 7 * i);
					var we = new Date(ws.getTime());
					we.setDate(we.getDate() + 7);
					if(duration != null && typeof(duration) == "number") {
						duration = new Date(aDate.getTime() + duration);
					}
					var containedObject = getDateRangeOverlap(new Date(aDate.getTime()),duration, ws,we);
					if(containedObject.contained) {
						//console.log("containedObject", containedObject.inRange);
						rows.push(containedObject);
					}
				}
				return rows.map(r=> {
					var coord = getCoordinatesOfDate(r.inRange.start);
					var width = Math.ceil((r.inRange.ended.getTime() - r.inRange.start.getTime()) / (60*60*24*1000))
					coord["width"] = width;
					coord["chopped"] = r.chopped;
					coord["allCoords"] = getOtherCoordsFromCoordAndWidth(coord, width);
					return coord;
				});
			}
			function correctNextCoordinate(x,y) {
				if(x>0 && y>0) {
					while(x>=7) {
						x-=7;
						y++;
					}
					if(y>6) {
						return null;
					} else {
						return ({x,y});
					}
				} else {
					return null;
				}
			}
			function getCoordinatesOfDate(aDate) {
				//console.log(`getCoordinatesOfDate(${aDate})`);
				let daysFromStart = (getDateAtZeroOClock(aDate).getTime() - getDateAtZeroOClock(calendarDiv.startDate).getTime()) / (1000 * 3600 * 24);
				let daysFromStartInt = parseInt(daysFromStart, 10);
				if(daysFromStart > daysFromStartInt) {
					daysFromStart = daysFromStartInt + 1;
				} else {
					daysFromStart = daysFromStartInt;
				}
				//console.log("daysFromStart",daysFromStart);
				if( aDate >= calendarDiv.startDate && aDate < calendarDiv.endedDate ) {
					let column = daysFromStart % 7;
					let row = parseInt(daysFromStart / 7);
					return ({column,row});
				} else {
					console.log("Date not on calendar used:", aDate);
					return null;					
				}
			}
			calendarDiv.showEvents = () => {
				var allEventsFiltered = getEventsBetween(calendarDiv.startDate, calendarDiv.endedDate);
				//console.log("allEventsFiltered", allEventsFiltered);
				allEventsFiltered = allEventsFiltered.map(m=> {
					let carrysOver = (m.duration != null) && (new Date(m.startDate.getTime() + m.duration)).getDate() != m.startDate.getDate();
					let hasIcon = (m.icon != null);
					let startsBeforeCalendar = (m.startDate < calendarDiv.startDate);
					let endedAfterCalendar = (m.duration!= null) && (new Date(m.startDate.getTime() + m.duration)) >= calendarDiv.endedDate;
					let coords = getAllCoordinatesOfADateRange(m.startDate, m.duration)
					return ({carrysOver, hasIcon, startsBeforeCalendar, coords, event: m});
				}).sort( (a,b) => {
					if(b.event.startDate.getTime() != a.event.startDate.getTime()) {
						return a.event.startDate.getTime() - b.event.startDate.getTime();
					} else {
						return (b.holdOver ? 1 : 0) - (a.holdOver ? 1 : 0);
					}
				});
				let dateDisplayReservations = Array.from(Array(6*7).keys()).map((m,i)=> {
					let x = i % 7;
					let y = parseInt(i/7, 10);
					let d = new Date( (calendarDiv.startDate).getTime() );
					d.setDate(d.getDate() + i);
					return {
						 x: x
						,y: y
						,d: d
						,slot1: null
						,slot2: null
						,slot3: null
						,icon1: null
						,icon2: null
						,icon3: null
						,icon4: null
						,iconsShiftedDown:  null
						,iconsShiftedRight: null
						,showOverflow: false
						,visibleIconCount: 0
						,slotOverflow: false
					};
				});
				//ICI rewrite next section to fit slots better
				console.log("allEventsFiltered",allEventsFiltered);
				//allEventsFiltered.forEach(thisEvent => {
				for(var thisEvent of allEventsFiltered) {
					let isSlot = (thisEvent.event.icon == null) || thisEvent.carrysOver;
					if(!isSlot) {
						//thisEvent.coords
						//thisEvent.coords.forEach(coord=> {
						for(var coord of thisEvent.coords) {
							let thisReservation = dateDisplayReservations.find(f=> f.x == coord.column && f.y == coord.row);
							if(thisReservation.icon1 == null) {
								thisReservation.icon1 = {event: thisEvent.event, coord};
								thisReservation.visibleIconCount++;
							} else if(thisReservation.icon2 == null) {
								thisReservation.icon2 = {event: thisEvent.event, coord};
								thisReservation.visibleIconCount++;
							} else if(thisReservation.icon3 == null) {
								thisReservation.icon3 = {event: thisEvent.event, coord};
								thisReservation.visibleIconCount++;
							} else if(thisReservation.icon4 == null) {
								thisReservation.icon4 = {event: thisEvent.event, coord};
								thisReservation.visibleIconCount++;
							} else {
								thisReservation.showOverflow = true;
								thisReservation.visibleIconCount++;
							}
							var eventWidth = coord.width;
							var bailOut=100;
							var nextDay = 1;
							while((eventWidth >= 2) && ((bailOut--) > 0)) {
								var correctedCoordinates = correctNextCoordinate(coord.column + nextDay, coord.row);
								if(correctedCoordinates != null) {
									thisReservation = dateDisplayReservations.find(f=> f.x == correctedCoordinates.x && f.y == correctedCoordinates.y);
									if(thisReservation.icon1 == null) {
										thisReservation.icon1 = {event: null, coord};
										thisReservation.visibleIconCount++;
									} else if(thisReservation.icon2 == null) {
										thisReservation.icon2 = {event: null, coord};
										thisReservation.visibleIconCount++;
									} else if(thisReservation.icon3 == null) {
										thisReservation.icon3 = {event: null, coord};
										thisReservation.visibleIconCount++;
									} else if(thisReservation.icon4 == null) {
										thisReservation.icon4 = {event: null, coord};
										thisReservation.visibleIconCount++;
									} else {
										thisReservation.showOverflow = true;
										thisReservation.visibleIconCount++;
									}
								}
								eventWidth--;
								nextDay++;
							}

							if(bailOut <= 0) {
								throw "Infinite loop error";
							}
						}//);
					} else {
						//thisEvent.coords.forEach(coord=> {

						for(var coord of thisEvent.coords) {
							let thisReservation = dateDisplayReservations.find(f=> f.x == coord.column && f.y == coord.row);
							if(thisReservation.slot1 == null) {
								thisReservation.slot1 = {event: thisEvent.event, coord};
								//console.log("consuming slot1 of", coord.column, coord.row, thisReservation);
								for(var eventWidth = 1; eventWidth<coord.width; eventWidth++) {
									//console.log("original point", `${coord.column}, ${coord.row}`, `offset: ${eventWidth}`);
									//console.log("finding date at coords", coord.column + eventWidth , coord.row);
									var correctedCoordinates = correctNextCoordinate(coord.column + eventWidth, coord.row);
									//console.log(" also slot1 of", correctedCoordinates);
									if(correctedCoordinates!= null) {
										let nextReservation = dateDisplayReservations.find(f=> f.x == correctedCoordinates.x && f.y == correctedCoordinates.y);
										if(nextReservation.slot1 == null) {
											nextReservation.slot1 = {event:null, coord};
										}
									}
								}
							} else if(thisReservation.slot2 == null) {
								thisReservation.slot2 = {event: thisEvent.event, coord};
								//console.log("consuming slot2 of", coord.column, coord.row, thisReservation);
								for(var eventWidth = 1; eventWidth<coord.width; eventWidth++) {
									var correctedCoordinates = correctNextCoordinate(coord.column + eventWidth, coord.row);
									//console.log(" also slot2 of", correctedCoordinates);
									if(correctedCoordinates!= null) {
										let nextReservation = dateDisplayReservations.find(f=> f.x == correctedCoordinates.x && f.y == correctedCoordinates.y);
										if(nextReservation.slot2 == null) {
											nextReservation.slot2 = {event:null, coord};
										}
									}
								}
							} else if(thisReservation.slot3 == null) {
								thisReservation.slot3 = {event: thisEvent.event, coord};
								//console.log("consuming slot3 of", coord.column, coord.row, thisReservation);
								for(var eventWidth = 1; eventWidth<coord.width; eventWidth++) {
									var correctedCoordinates = correctNextCoordinate(coord.column + eventWidth, coord.row);
									//console.log(" also slot3 of", correctedCoordinates);
									if(correctedCoordinates!= null) {
										let nextReservation = dateDisplayReservations.find(f=> f.x == correctedCoordinates.x && f.y == correctedCoordinates.y);
										if(nextReservation.slot3 == null) {
											nextReservation.slot3 = {event:null, coord};
										}
									}
								}
							} else {
								thisReservation.slotOverflow = true;
							}
						}//);
					}
				}
				console.log("dateDisplayReservations",dateDisplayReservations);
				dateDisplayReservations.forEach(f=> {
					//console.log(f.x,f.y, f.icon1);
					var dateBlockX = f.x * yWeekLine1;
					var dateBlockY = xWeekLine + f.y * xWeekLine1;
					var iconWidth = (yWeekLine1 - (yWeekLine1 / 4)) / 4;
					var iconHeight = xWeekLine1 / 4;
					var iconX1 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 0);
					var iconX2 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 1);
					var iconX3 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 2);
					var iconX4 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 3);
					var iconXC1 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 0) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4)/2);
					var iconXC2 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 1) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4)/2);
					var iconXC3 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 2) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4)/2);
					var iconXC4 = dateBlockX + (yWeekLine1 / 4) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4) * 3) + (((yWeekLine1 - (yWeekLine1 / 4)) / 4)/2);
					var iconY = dateBlockY;
					var iconYC = dateBlockY + ((xWeekLine1 / 4)/2);
					if(f.icon1 != null && f.icon1.event != null ) {
						// createSVGDom("rect", [{ x: iconX1, y: iconY, width: iconWidth, height: iconHeight, fill:"lightgreen"}],svgElement);
						var iconText = createSVGDom("text", [{
							 x: iconXC1
							,y: iconYC
							,width: iconWidth
							,height: iconHeight
							,text: f.icon1.event.icon
							,style: "cursor:pointer"
						},styleEventIconText],svgElement);
						var iconTitle = createSVGDom("title", null, iconText);
						iconTitle.textContent = f.icon1.event.name;
					}
					if(f.icon2 != null && f.icon2.event != null ) {
						// createSVGDom("rect", [{ x: iconX2, y: iconY, width: iconWidth, height: iconHeight, fill:"lightgreen"}],svgElement);
						var iconText = createSVGDom("text", [{
							 x: iconXC2
							,y: iconYC
							,width: iconWidth
							,height: iconHeight
							,text: f.icon2.event.icon
							,style: "cursor:pointer"
						},styleEventIconText],svgElement);
						var iconTitle = createSVGDom("title", null, iconText);
						iconTitle.textContent = f.icon2.event.name;
					}
					if(f.icon3 != null && f.icon3.event != null ) {
						// createSVGDom("rect", [{ x: iconX3, y: iconY, width: iconWidth, height: iconHeight, fill:"lightgreen"}],svgElement);
						var iconText = createSVGDom("text", [{
							 x: iconXC3
							,y: iconYC
							,width: iconWidth
							,height: iconHeight
							,text: f.icon3.event.icon
							,style: "cursor:pointer"
						},styleEventIconText],svgElement);
						var iconTitle = createSVGDom("title", null, iconText);
						iconTitle.textContent = f.icon3.event.name;
					}
					if(f.icon4 != null && f.icon4.event != null ) {
						// createSVGDom("rect", [{ x: iconX4, y: iconY, width: iconWidth, height: iconHeight, fill:"lightgreen"}],svgElement);
						var iconText = createSVGDom("text", [{
							 x: iconXC4
							,y: iconYC
							,width: iconWidth
							,height: iconHeight
							,text: f.icon4.event.icon
							,style: "cursor:pointer"
						}],svgElement);
						var iconTitle = createSVGDom("title", null, iconText);
						iconTitle.textContent = f.icon4.event.name;
					}

					var slotX = dateBlockX;
					var slotWidth = yWeekLine1; //TODO: 
					var slotHeight = (xWeekLine1 - (xWeekLine1 / 4))/3;
					var slotY1 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)*0);
					var slotY2 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)*1);
					var slotY3 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)*2);
					var slotYC1 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)/2) + ((xWeekLine1 / 4)*0);
					var slotYC2 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)/2) + ((xWeekLine1 / 4)*1);
					var slotYC3 = dateBlockY + (xWeekLine1 / 4) + ((xWeekLine1 / 4)/2) + ((xWeekLine1 / 4)*2);
					var slotXC = slotX + (slotWidth/2);
					if(f.slot1 != null && f.slot1.event != null) {
						if(f.slot1.event != null) {
							slotWidth = yWeekLine1 * f.slot1.coord.width;
						}
						createSVGDom("rect", [{ x: slotX, y: slotY1, width: slotWidth, height: slotHeight, rx: 5, ry: 5}, styleEventSlotBackground],svgElement);
						var slot1Rect = createSVGDom("rect", [{ x: slotX, y: slotY1, width: slotWidth, height: slotHeight, style: `clip-path: inset(0px 0px 0px 0px round ${f.slot1.coord.chopped.start ? 0 : 8 }px ${f.slot1.coord.chopped.ended ? 0 : 8 }px ${f.slot1.coord.chopped.ended ? 0 : 8 }px ${f.slot1.coord.chopped.start ? 0 : 8 }px);`}, styleEventSlotBackground],svgElement);
						createSVGDom("text", [{
							 //x: slotXC
							 x:slotX + (slotWidth*0.01) //+smidge
							,y: slotYC1
							,width: slotWidth
							,height: slotHeight
							,text: f.slot1.event.name
							,overrideCenterPosition: true
						}, styleEventSlotText],svgElement);
						var slot1Title = createSVGDom("title", null, slot1Rect);
						createSVGDom("foriegnObject", null, slot1Title).innerHTML = f.slot1.event.notes;
					}
					if(f.slot2 != null && f.slot2.event != null) {
						if(f.slot2.event != null) {//todo: this doesn't make since
							slotWidth = yWeekLine1 * f.slot2.coord.width;
						}
						createSVGDom("rect", [{ x: slotX, y: slotY2, width: slotWidth, height: slotHeight, rx: 5, ry: 5}, styleEventSlotBackground],svgElement);
						var slot2Rect = createSVGDom("rect", [{ x: slotX, y: slotY2, width: slotWidth, height: slotHeight, style: `clip-path: inset(0px 0px 0px 0px round ${f.slot2.coord.chopped.start ? 0 : 8 }px ${f.slot2.coord.chopped.ended ? 0 : 8 }px ${f.slot2.coord.chopped.ended ? 0 : 8 }px ${f.slot2.coord.chopped.start ? 0 : 8 }px);`}, styleEventSlotBackground],svgElement);
						createSVGDom("text", [{
							//x: slotXC
							 x: slotX + (slotWidth*0.01) //+smidge
							,y: slotYC2
							,width: slotWidth
							,height: slotHeight
							,text: f.slot2.event.name
							,overrideCenterPosition: true
						}, styleEventSlotText],svgElement);
						var slot2Title = createSVGDom("title", null, slot2Rect);
						createSVGDom("foriegnObject", null, slot2Title).innerHTML = f.slot2.event.notes;
					}
					if(f.slot3 != null && f.slot3.event != null) {
						if(f.slot3.event != null) {//todo: this doesn't make since
							slotWidth = yWeekLine1 * f.slot3.coord.width;
						}
						createSVGDom("rect", [{ x: slotX, y: slotY3, width: slotWidth, height: slotHeight, rx: 5, ry: 5}, styleEventSlotBackground],svgElement);
						var slot3Rect = createSVGDom("rect", [{ x: slotX, y: slotY3, width: slotWidth, height: slotHeight, style: `clip-path: inset(0px 0px 0px 0px round ${f.slot3.coord.chopped.start ? 0 : 8 }px ${f.slot3.coord.chopped.ended ? 0 : 8 }px ${f.slot3.coord.chopped.ended ? 0 : 8 }px ${f.slot3.coord.chopped.start ? 0 : 8 }px);`}, styleEventSlotBackground],svgElement);
						createSVGDom("text", [{
							//x: slotXC
							 x: slotX + (slotWidth*0.01) //+smidge
							,y: slotYC3
							,width: slotWidth
							,height: slotHeight
							,text: f.slot3.event.name
							,overrideCenterPosition: true
						}, styleEventSlotText],svgElement);
						var slot3Title = createSVGDom("title", null, slot3Rect);
						createSVGDom("foriegnObject", null, slot3Title).innerHTML = f.slot3.event.notes;
					}
				});
			};
			if(calendarDiv.displayEvents) {
				calendarDiv.showEvents();
			}
			return calendarDiv;
		}
		function calculateScale(sizeContainer, sizeContent) {
			const widthRatio = sizeContainer.width / sizeContent.width;
			const heightRatio = sizeContainer.height / sizeContent.height;
			const scale = Math.min(widthRatio, heightRatio);
			return scale;
		}
		function findExistingCalendars(elem) {
			var highestNumber = 0;
			var calendarDivs = elem.querySelectorAll('div[id^="calendar"]');
			calendarDivs.forEach(function(div) {
				var id = parseInt(div.id.replace('calendar', ''));
				if (id > highestNumber) {
					highestNumber = id;
				}
			});
			return highestNumber + 1; // Incrementing to get the next available number
		}
		function init() {
				//Add Coin event if missing
				let ruleProcessTo = new Date();
				ruleProcessTo.setFullYear(ruleProcessTo.getFullYear()+1);
				if( ! getAllRules().some(f=> f.name == "Coins") ) {
					let dateCoinDay = new Date();
					dateCoinDay.setDate(15);
					let coinDayRule = ({
						name: "Coins"
						,startDate: dateCoinDay
						,startDateIncludesTime: false
						,duration: null
						,durationIncludesTime: false
						,icon: "ü™ô"
						,desc: "Time to buy some coins"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: "monthly"
						,creationParameters: [1]
						,maxEvents: null
						,lastDay: null
					});
					addRule(coinDayRule, ruleProcessTo)
				}
				if( ! getAllRules().some(f=> f.name.toLowerCase() == "Weekly meeting".toLowerCase()) ) {
					let weeklyMeeting = new Date();
					weeklyMeeting.setMonth(0);
					weeklyMeeting.setDate(1);
					let weeklyMeetingRule = ({
						name: "Weekly meeting"
						,startDate: weeklyMeeting
						,startDateIncludesTime: false
						,duration: null
						,durationIncludesTime: false
						,icon: "üîî"
						,desc: "Scrum status meeting"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: "weekly"
						,creationParameters: [null,false,false,true,false,false,false,false]
						,maxEvents: null
						,lastDay: null
					});
					addRule(weeklyMeetingRule, ruleProcessTo)
				}
				if( ! getAllEvents().some(f=> f.name.toLowerCase() == "15th flight".toLowerCase()) ) {
					let fifthteenthFlight = new Date();
					fifthteenthFlight.setMonth(2);
					fifthteenthFlight.setDate(15);
					let fifthteenthFlightRule = ({
						name: "15th flight"
						,startDate: fifthteenthFlight
						,startDateIncludesTime: false
						,duration: null
						,durationIncludesTime: false
						,icon: "‚úàÔ∏è"
						,desc: "Scrum status meeting"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: "weekly"
						,creationParameters: [null,false,false,true,false,false,false,false]
						,maxEvents: null
						,lastDay: null
					});
					addEvent(fifthteenthFlightRule)
				}
				if( ! getAllEvents().some(f=> f.name.toLowerCase() == "Buy shirt".toLowerCase()) ) {
					let fifthteenthBuyShirt = new Date();
					fifthteenthBuyShirt.setMonth(2);
					fifthteenthBuyShirt.setDate(15);
					let fifthteenthBuyShirtRule = ({
						name: "Buy shirt"
						,startDate: fifthteenthBuyShirt
						,startDateIncludesTime: false
						,duration: null
						,durationIncludesTime: false
						,icon: "üëî"
						,desc: "Scrum status meeting"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: "weekly"
						,creationParameters: [null,false,false,true,false,false,false,false]
						,maxEvents: null
						,lastDay: null
					});
					addEvent(fifthteenthBuyShirtRule)
				}
				if( ! getAllEvents().some(f=> f.name.toLowerCase() == "Clean house".toLowerCase()) ) {
					let cleanHouse = new Date();
					cleanHouse.setMonth(2);
					cleanHouse.setDate(15);
					let cleanHouseRule = ({
						name: "Clean house"
						,startDate: cleanHouse
						,startDateIncludesTime: false
						,duration: null
						,durationIncludesTime: false
						,icon: "üßº"
						,desc: "Scrum status meeting"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: "weekly"
						,creationParameters: [null,false,false,true,false,false,false,false]
						,maxEvents: null
						,lastDay: null
					});
					addEvent(cleanHouseRule)
				}
				//Add 2 day event if missing
				if( ! getAllRules().some(f=> f.name == "2 day event") ) {
					let date2Day = new Date();
					date2Day = new Date(date2Day.getFullYear(), date2Day.getMonth(), 15);
					while(date2Day.getDay() != 3) {
						date2Day.setDate(date2Day.getDate()-1);
					}
					let twoDayRule = ({
						name: "2 day event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (2*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "2 dayer, wed on/before 15th"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}
				//Add overlapping 2 day event if missing
				if(false && ! getAllRules().some(f=> f.name == "overlapping event") ) {
					let date2Day = new Date();
					date2Day = new Date(date2Day.getFullYear(), date2Day.getMonth(), 15);
					while(date2Day.getDay() != 3) {
						date2Day.setDate(date2Day.getDate()-1);
					}
					let twoDayRule = ({
						name: "overlapping event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (2*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "2 dayer, wed on/before 15th"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}
				//Add second 2 day event if missing
				if(! getAllRules().some(f=> f.name.toLowerCase() == "Second 2 day event".toLowerCase())) {
					let date2Day = new Date();
					date2Day = new Date(date2Day.getFullYear(), date2Day.getMonth(), 15);
					while(date2Day.getDay() != 4) {
						date2Day.setDate(date2Day.getDate()-1);
					}
					let twoDayRule = ({
						name: "Second 2 day event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (2*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "2 dayer, thurs on/before 15th"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}
				//Add thrid 2 day event if missing
				if(! getAllRules().some(f=> f.name.toLowerCase() == "Third 2 day event".toLowerCase())) {
					let date2Day = new Date();
					date2Day = new Date(date2Day.getFullYear(), date2Day.getMonth(), 15);
					let twoDayRule = ({
						name: "Third 2 day event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (2*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "2 dayer, on 15th"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}
				//Add wrapping weekend event
				if(! getAllRules().some(f=> f.name.toLowerCase() == "Wrapping event".toLowerCase())) {
					let date2Day = new Date(2024,2,15);
					let twoDayRule = ({
						name: "Wrapping event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (3*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "event that wraps over a weekend"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}
				//Previous month wrap
				if(! getAllRules().some(f=> f.name.toLowerCase() == "Previous Month event".toLowerCase())) {
					let date2Day = new Date(2024,1,24);
					let twoDayRule = ({
						name: "Previous Month event"
						,startDate: date2Day
						,startDateIncludesTime: false
						,duration: (4*24*60*60*1000)
						,durationIncludesTime: false
						,icon: null
						,desc: "event that wraps over a previous month"
						,notes: "GUI<h1>here</h1>"
						,location: "Shoppe"
						,important: false
						,holiday: false
						,countDown: false
						,reminder: null
						,creationType: null
						,creationParameters: null
						,maxEvents: null
						,lastDay: null
					});
					addRule(twoDayRule, ruleProcessTo)
				}


				
				var width = 800*2;
				var height = 600*2;
				var x = 10;
				var y = 10;

				var calendarOptions = ({
					 weekStart: 0,
					 useShortMonthName: true
					,useShortYear: true
					,useShortWeekName: false
					,highlightWrongMonths: true
					,showMonthNavigation: true
					,displayEvents: true
				});

				var theme = getTheme("default");

				// theme.styleWeekend = {
				// 					 opacity: 0.2
				// 					,fill: "blue"
				// 				};

				calendarOptions = Object.assign(calendarOptions, theme);
				var c = createCalendar(width, height, x, y, new Date(), calendarOptions, document.body);

				console.log(c.startDate, c.endedDate, c.displayedDate);
				//c.addEvent(new Date(2024,1,28),1, "üçå");ü™ô

				//c.showEvents();

		}
		window.onload = function() {
			init();
		};
		//‚ÜïÔ∏è
	</script>
</html>